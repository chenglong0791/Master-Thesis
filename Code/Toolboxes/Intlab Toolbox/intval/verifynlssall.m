function [List,ListS,ListData] = verifynlssall(f,x0,opt,varargin)
%VERIFYNLSSALL  Global nonlinear system solver
%
%Finds all zeros of a function f:R^n->R^n within the box x0. 
%
%The function f needs to be in "vectorized form", i.e. [f(x) f(y)] and f([x y]) 
%must be equal. To achieve that, replace operations "o" by ".o" and replace 
%direct access to components x(i) by x(i,:). 
%If f is a function handle or a character string, this may be achieved 
%by funvec(f); if f is an inline function, it is converted automatically. 
%
%Standard calls are
%
%   [ X , XS ] = verifynlssall(f,x0)              or
%   [ X , XS , Data ] = verifynlssall(f,x0)
%
%or with optional parameters to be set by verifynlssallset
%(if opt is omitted or empty, default paramaters are used)
%
%   [ X , XS , Data ] = verifynlssall(f,x0,opt)
%
%The output parameter Data stores data to continue the search, for example by
%
%   [ X , XS ] = verifynlssall(Data)
%   for k=1:kmax
%     [ X , XS , Data ] = verifynlssall(f)
%   end
%
%or, similarly,
%
%   [ X , XS , Data] = verifynlssall(Data,opt)
%
%Similarly,
%
%   [ X , XS ] = verifynlssall(f,x0,[],param1,param2,...)   or
%   [ X , XS ] = verifynlssall(f,x0,opt,param1,param2,...)
%
%evaluates the function f with extra paramaters param1, param2 ...
%
%Upon completion, X is an n x K array, each column containing a unique zero
%of f, whereas XS is an n x L array possibly containing a zero of f. 
%
%input    f         f:R^n->R^n, function to find all zeros in x0
%         x0        box to be searched
%         opt.fields  optional, if not specified, default values are used
%             Display   0    no extra display (default)
%                       1    see information on the iteration progress
%                       'x'   for 1<=n<=3, plots of the iteration progress,
%                               boxes filled with color 'x'
%                       '~'   same but with random color
%                       's'   same but only skeleton
%                       '.p'  same as above but with pause after some iterations
%             Boxes     'bisection' into boxes subboxes, default 2^6
%             iFunMax   maximal number of function evaluations, default 1e6
%             TolXAbs   Termination absolute tolerance on inclusions X
%             TolXRel   Termination relative tolerance on inclusions X
%             NIT       optional, default nit = 5
%             ND        optional, default nd  = 3
%output   X         n x K array of K inclusion boxes of unique zeros of f within x0
%         XS        n x L array of L possible inclusion boxes
%         Data      Data to continue search
%
%Parameters in opt may be set by "verifynlssallset":
%   opt = verifynlssallset('boxes',256);
%or directly
%   [X,Xs] = verifynlssall(@(x)cos(x^2)+atan(x-erf(x)-asinh(x^3)),infsup(-5,5),verifynlssallset('display','~'))
%The List XS of possible inclusion boxes might be long. To collect boxes
%with a significant part in common, use 
%   XS = collectList(XS);
%For long lists that might take a considerable amout of computing time,
%depending on the structure of XS. Therefore, collection in not included
%here. For details and examples, see collectList.
%
%Internally the algorithm is repeated recursively NIT times, where all
%boxes on the list are bisected ND times, respectively. 
%
%Using ideas in
%  O. Knüppel: Einschließungsmethoden zur Bestimmung der Nullstellen
%     nichtlinearer Gleichungssysteme und ihre Implementierung.
%     PhD thesis, Hamburg University of Technology, 1994.
%

% written  02/27/17  S.M. Rump
% modified 07/06/17  S.M. Rump  Final check for vectorization: f = @(x) g(g(x))
%                                 may fail (thanks to Thomas Wanner)
% modified 07/19/17  S.M. Rump  optimset
% modified 07/30/17  S.M. Rump  maximal number of function evaluations
% modified 12/12/17  S.M. Rump  check call with correct data
%

  global INTLAB_NLSS
  global INTLAB_CONST
  global INTLAB_DERIV_CALLED
  
  rndold = getround;
  if rndold
    setround(0)
  end
  
  % ignore input out of range; NaN ~ empty
  INTLAB_CONST.RealStdFctsExcptnIgnore = 1;
  % make sure that is reset
  dummy = onCleanup(@()restore);
  
  refine = isstruct(f);
  
  if refine                             % refinement call
    
    Data = f;
    if INTLAB_DERIV_CALLED
      fname = 'verifynlssderivall';
    else
      fname = 'verifynlssall';
    end
    if ~isequal(Data.Filename,fname)    % check for data
      error(['Stored data was generated by ' Data.Filename])
    end
    if nargin>1
      opt = x0;
    end
    INTLAB_NLSS = Data.INTLAB_NLSS;
    INTLAB_DERIV_CALLED = false;
    
  else                                  % first call
    
    if ( ~isintval(x0) ) && ( ~isaffari(x0) )
      error('Constraint box must be intval or affari')
    end
    if size(x0,2)~=1
      error('Input box must be column vector')
    end
    
    INTLAB_NLSS = [];
    
    initconstants;
    
    INTLAB_NLSS.NLSSALL = 1;
    if INTLAB_DERIV_CALLED
      INTLAB_NLSS.DERIV = INTLAB_DERIV_CALLED;
      INTLAB_DERIV_CALLED = false;
    else
      INTLAB_NLSS.DERIV = false;
    end
    INTLAB_NLSS.GLOBOPT = 0;
    INTLAB_NLSS.CONSTRAINT = 0;
    
    if nargin<4
      param = {};
    else
      param = varargin;
    end
    INTLAB_NLSS.param = param;
    
    INTLAB_NLSS.F = funvec(f,mid(x0),[],param);  % vectorize
    checkfunvec(INTLAB_NLSS.F,x0,param);  % check f is vectorized
    
    INTLAB_NLSS.N = size(x0,1);           % number of unknowns
    
    INTLAB_NLSS.X0 = x0;
    % define slightly extended region
    INTLAB_NLSS.X0_ = INTLAB_NLSS.X0*midrad(1,0.001);
    INTLAB_NLSS.X0rad = rad(INTLAB_NLSS.X0);
    
    INTLAB_NLSS.CurrentX0 = INTLAB_NLSS.X0;
    INTLAB_NLSS.CurrentX0_ = INTLAB_NLSS.X0*midrad(1,1e-8);
    INTLAB_NLSS.kappa = [];          % stores unique solutions and function values
    INTLAB_NLSS.GAMMA = intval([]);  % expanded kapa
    INTLAB_NLSS.DAME = intval([]);   % don't run local optimizer
    
  end
  
  if ( nargin<3 ) || isempty(opt)
    if refine && ( nargin==1 )
      opt = INTLAB_NLSS.opt;
    else
      opt = verifynlssallset;
    end
  else
    opt = verifynlssallset(opt);
  end
  INTLAB_NLSS.opt = opt;
  INTLAB_NLSS.IFUN = 0;
  
  INTLAB_NLSS.SEE = opt.Display;
  INTLAB_NLSS.BOXES = opt.Boxes;
  INTLAB_NLSS.IFUNMAX = opt.iFunMax;
  INTLAB_NLSS.TOLXABS = opt.TolXAbs;
  INTLAB_NLSS.TOLXREL = opt.TolXRel;
  INTLAB_NLSS.NIT = opt.NIT;
  INTLAB_NLSS.ND = opt.ND;
  
  if ischar(INTLAB_NLSS.SEE) && ( INTLAB_NLSS.N>3 )
    warning('Graphical output up to 3 unknowns')
    INTLAB_NLSS.SEE = 1;
  end
  
  if INTLAB_NLSS.BOXES<2
    error('bisection into at least two subboxes')
  end
  
  if ( nargin>=4 ) && isstruct(x0)
    error('parameters already specified.')
  end
    
  if refine                % refinement
    see = INTLAB_NLSS.SEE;
    if ischar(see)
      INTLAB_NLSS.SEE = 0; % possibly many boxes for refinement
    end
    ListData = verifyglobalrefine(Data);
    INTLAB_NLSS.SEE = see;
  else
    ListData = verifyglobal(x0);
    if INTLAB_DERIV_CALLED
      ListData.Filename = 'verifynlssderivall';
    else
      ListData.Filename = 'verifynlssall';
    end
  end

  % combine results
  List = ListData.kappa;
  ListS = ListData.ListS;
  
  if isempty(List)
    List = [];
  end
  
  if isempty(ListS)
    ListS = [];
  end
  
  if ischar(INTLAB_NLSS.SEE) && ( ~refine )  % first call, not refinement
    plotsmallboxes(List,ListS)
  end
  
  setround(rndold)

end  % verifynlssall
