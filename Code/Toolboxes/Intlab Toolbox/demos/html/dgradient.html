
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>DEMOGRADIENT  Short demonstration of gradients</title><meta name="generator" content="MATLAB 9.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2017-07-22"><meta name="DC.source" content="dgradient.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>DEMOGRADIENT  Short demonstration of gradients</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Some sample applications of the gradient toolbox</a></li><li><a href="#2">Initialization of gradients</a></li><li><a href="#4">Operations between gradients</a></li><li><a href="#6">Complex arguments</a></li><li><a href="#7">Access to the gradient</a></li><li><a href="#14">The inverse Gamma function</a></li><li><a href="#15">The inverse Gamma function with complex arguments</a></li><li><a href="#18">Automatic differentiation with several unknowns</a></li><li><a href="#19">Solution of a nonlinear system</a></li><li><a href="#21">Verified solution of the nonlinear system</a></li><li><a href="#23">Real and interval function evaluation</a></li><li><a href="#26">Gradient function evaluation using ordinary intervals</a></li><li><a href="#28">Gradient function evaluation using affine intervals</a></li><li><a href="#29">Verified solution of the nonlinear system with Broyden's function</a></li><li><a href="#31">All roots of Broyden's function</a></li><li><a href="#33">Verified solution of a nonlinear system with sparse gradients</a></li><li><a href="#35">Verified solution of a nonlinear system with full gradients</a></li><li><a href="#36">Verified solution of a nonlinear system with 10,000 unknowns</a></li><li><a href="#37">Non-differentiable functions</a></li><li><a href="#38">Verified solution of non-differentiable functions</a></li><li><a href="#43">Enjoy INTLAB</a></li></ul></div><h2 id="1">Some sample applications of the gradient toolbox</h2><p>The gradient toolbox implements automatic differentiation in forward mode.</p><h2 id="2">Initialization of gradients</h2><p>In order to use automatic differentiation, the independent variables need to be identified and values have to be assigned. This is performed by the function "gradientinit". For example</p><pre class="codeinput">format <span class="string">compact</span> <span class="string">short</span> <span class="string">_</span>
u = gradientinit([ -3.1 ; 4e-3 ])
</pre><pre class="codeoutput">gradient value u.x = 
   -3.1000
    0.0040
gradient derivative(s) u.dx = 
     1     0
     0     1
</pre><p>The total size of the input is the number of independent variables, in the example 2, hence u represents a column vector of length 2 and defines two independent variables u(1) and u(2) with gradients [1 0] and [0 1], respectively.</p><h2 id="4">Operations between gradients</h2><p>If at least one operand is of type gradient, operations are executed as gradient operations. For example,</p><pre class="codeinput">x = gradientinit(3.5);
y = exp(3*x-sqrt(x))
</pre><pre class="codeoutput">gradient value y.x = 
   5.5924e+03
gradient derivative(s) y.dx = 
   1.5283e+04
</pre><p>For f(x):=exp(3*x-sqrt(x)), the result y contains in y.x the function value f(3.5) and in y.dx the derivative f'(3.5):</p><pre class="codeinput">y.x, y.dx
</pre><pre class="codeoutput">ans =
   5.5924e+03
ans =
   1.5283e+04
</pre><h2 id="6">Complex arguments</h2><p>When evaluating the expression for another argument, use the same statement as before with new values.</p><pre class="codeinput">x = gradientinit(-3.5+.2i);
y = exp(3*x-sqrt(x))
</pre><pre class="codeoutput">gradient value y.x = 
   7.6944e-06 - 2.4944e-05i
gradient derivative(s) y.dx = 
   2.9683e-05 - 7.2588e-05i
</pre><h2 id="7">Access to the gradient</h2><p>The principle works for functions in several unknowns the same way. Define, for example, the following function from R^3-&gt;R^3 :</p><pre class="codeinput">f = @(x)( [ -2*x(1)*x(2)+4*x(3)^2 ; sin(x(2))/sqrt(pi-x(1)) ; atan(x(2)-x(3)) ] )
f([1.5;-1;0.7])
</pre><pre class="codeoutput">f =
  function_handle with value:
    @(x)([-2*x(1)*x(2)+4*x(3)^2;sin(x(2))/sqrt(pi-x(1));atan(x(2)-x(3))])
ans =
    4.9600
   -0.6568
   -1.0391
</pre><p>then the function value and gradient at [1.5;-1;0.7] is computed by</p><pre class="codeinput">y = f(gradientinit([1.5;-1;0.7]))
</pre><pre class="codeoutput">gradient value y.x = 
    4.9600
   -0.6568
   -1.0391
gradient derivative(s) y.dx = 
    2.0000   -3.0000    5.6000
   -0.2000    0.4217         0
         0    0.2571   -0.2571
</pre><p>where y.x contains the function value and y.dx the gradient, which is in this case the Jacobian. The gradient with respect the third unknown x(3), for example, can be accessed by</p><pre class="codeinput">y.dx(3,:)
</pre><pre class="codeoutput">ans =
         0    0.2571   -0.2571
</pre><p>However, it is recommended to use</p><pre class="codeinput">y(3).dx
</pre><pre class="codeoutput">ans =
         0    0.2571   -0.2571
</pre><p>that is not to access the components of the gradient (Jacobian) but the gradient of the component. The advantage is visible when redefining the input function as a row vector:</p><pre class="codeinput">f = @(x)( [ -2*x(1)*x(2)+4*x(3)^2  sin(x(2))/sqrt(pi-x(1))  atan(x(2)-x(3)) ] )
f([1.5;-1;0.7])
</pre><pre class="codeoutput">f =
  function_handle with value:
    @(x)([-2*x(1)*x(2)+4*x(3)^2,sin(x(2))/sqrt(pi-x(1)),atan(x(2)-x(3))])
ans =
    4.9600   -0.6568   -1.0391
</pre><p>Then the "Jacobian" is a three-dimensional array because the gradient is always stored in the "next" dimension:</p><pre class="codeinput">y = f(gradientinit([1.5;-1;0.7]))
</pre><pre class="codeoutput">gradient value y.x = 
    4.9600   -0.6568   -1.0391
gradient derivative(s) y.dx(1,1,:) = 
    2.0000   -3.0000    5.6000
gradient derivative(s) y.dx(1,2,:) = 
   -0.2000    0.4217         0
gradient derivative(s) y.dx(1,3,:) = 
         0    0.2571   -0.2571
</pre><p>It is problematic to access the components of y.dx, while accessing the gradient of the component works as expected:</p><pre class="codeinput">y(3).dx
</pre><pre class="codeoutput">ans =
         0    0.2571   -0.2571
</pre><h2 id="14">The inverse Gamma function</h2><p>We may want to calculate the inverse Gamma function using INTLAB's verified Gamma function. For example, compute u such that gamma(u) = 100. Consider the following simple Newton procedure with starting value u=5.</p><pre class="codeinput">format <span class="string">long</span>
u = gradientinit(5);
uold = u;
k = 0;
<span class="keyword">while</span> abs(u.x-uold.x) &gt; 1e-12*abs(u.x) | k &lt; 1
  uold = u;
  k = k+1;
  y = gamma(u) - 100;
  u = u - y.x/y.dx;
<span class="keyword">end</span>
k
u.x
gamma(u.x)
</pre><pre class="codeoutput">k =
     9
ans =
   5.892518696343773
ans =
   100
</pre><h2 id="15">The inverse Gamma function with complex arguments</h2><p>Neither Matlab nor INTLAB provide the Gamma function for complex arguments. However, we may use an approximation by Stirling's formula. For u -&gt; inf,</p><pre>                       1      1       139        571
 Gamma(u) ~ C * ( 1 + --- + ----- - ------- - --------- + ... )
                      12u       2         3           4
                            288u    51840u    2488320u</pre><p>with</p><pre>      -u  u-0.5
 C = e   u      sqrt(2*pi) .</pre><p>The following function evaluates Stirling's formula. It is also suited for vector input.</p><pre class="language-matlab"><span class="keyword">function</span> y = g(u)
    C = exp(-u) .* ( u.^(u-0.5) ) * sqrt(2.0*pi) ;
    v = (((( -571.0/2488320.0 ./ u - 139.0/51840.0 ) ./ u <span class="keyword">...</span>
         + 1.0/288.0) ./ u ) + 1.0/12.0 ) ./ u + 1.0;
    y = C .* v;
</pre><p>A corresponding inline function is</p><pre class="codeinput">format <span class="string">long</span> <span class="string">e</span>
g = @(u) ( ( exp(-u) .* ( u.^(u-0.5) ) * sqrt(2.0*pi) ) .* <span class="keyword">...</span>
           ( (((( -571.0/2488320.0 ./ u - 139.0/51840.0 ) ./ u <span class="keyword">...</span>
             + 1.0/288.0) ./ u ) + 1.0/12.0 ) ./ u + 1.0 ) )
u = [ 3.5 61 5 ]
g(u)
gamma(intval(u))
</pre><pre class="codeoutput">g =
  function_handle with value:
    @(u)((exp(-u).*(u.^(u-0.5))*sqrt(2.0*pi)).*(((((-571.0/2488320.0./u-139.0/51840.0)./u+1.0/288.0)./u)+1.0/12.0)./u+1.0))
u =
     3.500000000000000e+00     6.100000000000000e+01     5.000000000000000e+00
ans =
     3.323346278704310e+00     8.320987112733666e+81     2.399999414518977e+01
intval ans = 
  3.32335097044784_e+000  8.32098711274139_e+081  2.400000000000000e+001
</pre><p>Note however that the approximation by Stirling's formula is of limited accuracy. The last line, a verified inclusion by INTLAB's Gamma function, indicates about 6 to 11 correct figures, depending on the magnitude of the argument.</p><p>Using Stirling's formula we may search u with g(u) = 100 + 100i. We use the same starting value u=5.</p><pre class="codeinput"> u = gradientinit(5);
 uold = u;
 k = 0;
 <span class="keyword">while</span> abs(u.x-uold.x) &gt; 1e-12*abs(u.x) | k &lt; 1
  uold = u;
  k = k+1;
  y = g(u) - 100 - 100i;
  u = u - y.x/y.dx;
 <span class="keyword">end</span>
 k
 u.x
 g(u.x)
</pre><pre class="codeoutput">k =
    10
ans =
      6.701615293582063e+00 + 3.757828161591650e+00i
ans =
      1.000000000000003e+02 + 1.000000000000002e+02i
</pre><p>Due to approximation error in Stirling's formula, about six figures are correct.</p><h2 id="18">Automatic differentiation with several unknowns</h2><p>Automatic differentiation with several unknowns works the same way. Consider the following example by Broyden:</p><pre>                             .5*sin(x1*x2) - x2/(4*pi) - x1/2  =  0
(1-1/(4*pi))*(exp(2*x1)-exp(1)) + exp(1)*x2/pi - 2*exp(1)*x1 )  =  0</pre><p>with initial approximation [ .6 ; 3 ] and one solution [ .5 ; pi ]. The following inline function evaluates Broyden's function.</p><pre class="codeinput">f = @(x) ( [ .5*sin(x(1)*x(2)) - x(2)/(4*pi) - x(1)/2 ; <span class="keyword">...</span>
             (1-1/(4*pi))*(exp(2*x(1))-exp(1)) + exp(1)*x(2)/pi - 2*exp(1)*x(1) ] )
</pre><pre class="codeoutput">f =
  function_handle with value:
    @(x)([.5*sin(x(1)*x(2))-x(2)/(4*pi)-x(1)/2;(1-1/(4*pi))*(exp(2*x(1))-exp(1))+exp(1)*x(2)/pi-2*exp(1)*x(1)])
</pre><h2 id="19">Solution of a nonlinear system</h2><p>The nonlinear system defined by Broyden's function is solved by Newton's procedure as follows:</p><pre class="codeinput"> x = gradientinit([ .6 ; 3 ]);
 <span class="keyword">for</span> i=1:5
  y = f(x);
  x = x - y.dx\y.x;
 <span class="keyword">end</span>
 x
</pre><pre class="codeoutput">gradient value x.x = 
     4.999999999999999e-01
     3.141592653589794e+00
gradient derivative(s) x.dx = 
     1     0
     0     1
</pre><p>For simplicity, we omitted the stopping criterion (see above). Here, y.dx is the Jacobian, y.x the function value at x.x, and -y.dx\y.x is the correction obtained by the (approximate) solution of a linear system.</p><h2 id="21">Verified solution of the nonlinear system</h2><p>For verified solution of the nonlinear system, we need a correct definition of the function. The main point is to make sure that a function evaluation with interval argument computes an inclusion of the function value. So first the transcendental number pi has to be replaced by an interval containing pi:</p><pre class="codeinput">cPi = intval(<span class="string">'pi'</span>)
</pre><pre class="codeoutput">intval cPi = 
  3.141592653589794e+000
</pre><p>Second, Broyden's function contains exp(1), which would be computed in pure floating-point without extra care. This can be cured using exp(intval(1)).</p><p>However, a new problem arises. When replacing "pi" in the function by "cPi" and 1 by intval(1), the function is <i>always</i> evaluated in interval arithmetic; a pure floating point iteration is no longer possible.</p><p>To solve this problem, we have to know the type of the incoming unknown "x". If "x" is double, replace "cPi" and intval(1) by its midpoint, if "x" is an interval, use "cPi" and intval(1) as is. This is done as follows.</p><pre>function  y = f(x)
  y = x;
  c1 = typeadj( 1 , typeof(x) );
  cpi = typeadj( midrad(3.14159265358979323,1e-16) , typeof(x) );
  y(1) = .5*sin(x(1)*x(2)) - x(2)/(4*cpi) - x(1)/2;
  y(2) = (1-1/(4*cpi))*(exp(2*x(1))-exp(c1)) + exp(c1)*x(2)/cpi - 2*exp(c1)*x(1);</pre><p>This code is implemented in the function Broyden.m .</p><h2 id="23">Real and interval function evaluation</h2><p>Consider the following two function evaluations. First, f(x) is evaluated for real argument:</p><pre class="codeinput">x = [ .6 ; 3 ];
Broyden(x)
</pre><pre class="codeoutput">ans =
    -5.180859919874536e-02
    -1.122276766667780e-01
</pre><p>Second, f(x) is evaluated with interval argument:</p><pre class="codeinput">format <span class="string">_</span>
x = [intval(<span class="string">'.6'</span>) ; 3 ]
y = Broyden(x)
</pre><pre class="codeoutput">intval x = 
  6.00000000000000_e-001
  3.000000000000000e+000
intval y = 
 -5.1808599198745__e-002
 -1.1222767666678__e-001
</pre><p>The mathematical statement is the following. First, x is an interval vector such that x(1) is an inclusion of 0.6 and x(2)=3. Second, cPi is an interval containg the transcendental number pi. Third, y is an interval vector containing the exact value of Broyden's function evaluated at [ .6 ; 3 ].</p><h2 id="26">Gradient function evaluation using ordinary intervals</h2><p>Finally, we may define the interval x to be of type gradient:</p><pre class="codeinput">x = gradientinit([intval(<span class="string">'.6'</span>) ; 3 ])
Y = Broyden(x)
</pre><pre class="codeoutput">intval gradient value x.x = 
  6.00000000000000_e-001
  3.000000000000000e+000
intval gradient derivative(s) x.dx = 
  1.000000000000000e+000   0.000000000000000e+00
   0.000000000000000e+00  1.000000000000000e+000
intval gradient value Y.x = 
 -5.1808599198745__e-002
 -1.1222767666678__e-001
intval gradient derivative(s) Y.dx = 
 -8.40803142039631_e-001 -1.47738099953874_e-001
  6.7525716865843__e-001  8.65255979432265_e-001
</pre><p>The mathematical statement is that Y is an interval vector such that Y.x contains the exact value of Broyden's function evaluated at [ .6 ; 3 ], and Y.dx is an interval matrix containing the Jacobian of Broyden's function evaluated at [ .6 ; 3 ].</p><h2 id="28">Gradient function evaluation using affine intervals</h2><p>We may use affine arithmetic in gradient evaluations as well, for details see the affari demo:</p><pre class="codeinput">x = gradientinit([affari(.6) ; 3 ])
Y = Broyden(x)
</pre><pre class="codeoutput">affari gradient value x.x = 
  6.000000000000000e-001
  3.000000000000000e+000
affari gradient derivative(s) x.dx = 
  1.000000000000000e+000   0.000000000000000e+00
   0.000000000000000e+00  1.000000000000000e+000
affari gradient value Y.x = 
 -5.1808599198745__e-002
 -1.1222767666678__e-001
affari gradient derivative(s) Y.dx = 
 -8.40803142039630_e-001 -1.47738099953874_e-001
  6.7525716865843__e-001  8.65255979432265_e-001
</pre><h2 id="29">Verified solution of the nonlinear system with Broyden's function</h2><p>The nonlinear system with Broyden's function and the given starting value [ .6 ; 3 ] can be solved with verification by</p><pre class="codeinput">Y = verifynlss(@Broyden,[ .6 ; 3 ])
</pre><pre class="codeoutput">intval Y = 
  5.00000000000000_e-001
  3.14159265358979_e+000
</pre><p>The first parameter gives the name of the function such that Broyden(x) evaluates the function at "x". The result vector Y is verified to contain a real vector xhat such that f(xhat)=0. This solution X of the nonlinear system is proved to be unique within Y. This statement is mathematically true, it is taken care of all procedural, approximation and rounding errors.</p><p>It follows that an inclusion is not possible if roots are very close together or multiple: Since uniqueness of the root is proved, an inclusion is only possible if roots can be separated. An escape of that is described in DEMOSLOPE.</p><h2 id="31">All roots of Broyden's function</h2><p>The root [ 0.5 ; pi ] is mentioned in the literature, however, there are many more roots. For example, there are seven roots in the box [-10,10]^2</p><pre class="codeinput">format <span class="string">short</span>
L = verifynlssall(@Broyden,infsup(-10,10)*ones(2,1))
</pre><pre class="codeoutput">intval L = 
   -0.2606    0.5000    1.4339    1.4813    1.3374    0.2994    1.2943
    0.6225    3.1415   -6.8207   -8.3836   -4.1404    2.8369   -3.1372
</pre><p>For more details, please visit the demo on global routines by demo toolbox intlab .</p><h2 id="33">Verified solution of a nonlinear system with sparse gradients</h2><p>Up to now we considered only toy examples to explain how the nonlinear system solver works. For a larger example consider the following example proposed by Abbot and Brent, which is implemented in the function test.</p><pre>function y = test(x);
% Abbot/Brent     3 y" y + y'^2 = 0;    y(0)=0; y(1)=20;
% approximation   10*ones(n,1)
% solution        20*x^.75
  y = x;
  n = length(x); v=2:n-1;
  y(1) = 3*x(1)*(x(2)-2*x(1)) + x(2)*x(2)/4;
  y(v) = 3*x(v).*(x(v+1)-2*x(v)+x(v-1)) + (x(v+1)-x(v-1)).^2/4;
  y(n) = 3*x(n).*(20-2*x(n)+x(n-1)) + (20-x(n-1)).^2/4;</pre><p>An inclusion of the solution for 1000 unknowns is computed by</p><pre class="codeinput">format <span class="string">short</span>
sparsegradient(50)
n = 1000;
tic
x = verifynlss(@test,10*ones(n,1));
toc
max(relerr(x))
</pre><pre class="codeoutput">===&gt; Gradient derivative stored sparse for 50 and more unknowns
ans =
    50
Elapsed time is 0.236515 seconds.
ans =
   3.8277e-16
</pre><h2 id="35">Verified solution of a nonlinear system with full gradients</h2><p>Here we specified that gradients with 50 unknowns and more are stored in sparse mode. This is the default when calling "sparsegradient".</p><p>Forcing gradients to use full storage results in a significantly increase of computing time.</p><pre class="codeinput">sparsegradient(inf)
n = 1000;
tic
x = verifynlss(@test,10*ones(n,1));
toc
max(relerr(x))
</pre><pre class="codeoutput">===&gt; Gradient derivative always stored full
ans =
   Inf
Elapsed time is 1.522042 seconds.
ans =
   3.8277e-16
</pre><h2 id="36">Verified solution of a nonlinear system with 10,000 unknowns</h2><p>Note that the inclusion is of high accuracy. The results for a larger nonlinear system with 10,000 unknowns is as follows.</p><pre class="codeinput">sparsegradient(0)
n = 10000;
tic
x = verifynlss(@test,10*ones(n,1));
toc
max(relerr(x))
</pre><pre class="codeoutput">===&gt; Gradient derivative always stored sparse
ans =
     0
Elapsed time is 31.517108 seconds.
ans =
   5.3780e-16
</pre><h2 id="37">Non-differentiable functions</h2><p>The given function need not be differentiable everywhere. Consider, for example,</p><pre class="codeinput">f = inline(<span class="string">'abs(x)'</span>)
f(gradientinit(infsup(-.1,2)))
</pre><pre class="codeoutput">f =
     Inline function:
     f(x) = abs(x)
intval gradient value ans.x = 
[    0.0000,    2.0000] 
intval gradient derivative(s) ans.dx = 
  (1,1)             [   -1.0000,    1.0000] 
</pre><h2 id="38">Verified solution of non-differentiable functions</h2><p>The inclusion of a root is searched for near the given approximation. Consider</p><pre class="codeinput">f = vectorize(inline(<span class="string">'x*sinh(x)-3*exp(abs(x)-.5)+x*cos(x+1)+2*cosh(x)'</span>))
close
x=linspace(-1,2.3);
plot(x,f(x),x,0*x)
</pre><pre class="codeoutput">f =
     Inline function:
     f(x) = x.*sinh(x)-3.*exp(abs(x)-.5)+x.*cos(x+1)+2.*cosh(x)
</pre><img vspace="5" hspace="5" src="dgradient_01.png" alt=""> <p>It seems there are three roots. Indeed,</p><pre class="codeinput">format <span class="string">long</span>
verifynlss(f,-.5)
verifynlss(f,.5)
verifynlss(f,2)
</pre><pre class="codeoutput">intval ans = 
  -0.07707181827987
intval ans = 
   0.14381565238483
intval ans = 
   2.14372206306996
</pre><p>there are three roots, and the inlcusions are of high accuracy. One can also calculate an inclusion of multiple roots. Since the problem is ill-posed, it has to be regularized. Consider</p><pre class="codeinput">X = verifynlss2(@(x)(sin(x)-1),1.5)
</pre><pre class="codeoutput">intval X = 
   1.57079632679489
  -0.00000000000000
</pre><p>It is proved that there exists some parameter e in X(2) such that the function g(x):=f(x)-e has a truely double root in X(1). Note the accuracy of the inclusions. It looks like the inclusion of e is a true zero. However, this is due to the "_"-format: add +/-1 to the last visible digit produces a valid inclusion:</p><pre class="codeinput">format <span class="string">long</span> <span class="string">e</span> <span class="string">infsup</span>
X
</pre><pre class="codeoutput">intval X = 
[  1.570796326794895e+000,  1.570796326794897e+000] 
[ -1.110223024625157e-016,  2.465190328815663e-032] 
</pre><p>The function "verifynlss2" is applicable to multivariate functions as well. For more details, see "help verifynlss" or "help verifynlss2" or</p><pre>S.M. Rump: Verification methods: Rigorous results using floating-point arithmetic.
  Acta Numerica, 19:287-449, 2010.</pre><p>to be downloaded from "www.ti3.tuhh.de/rump" and the literature cited over there.</p><h2 id="43">Enjoy INTLAB</h2><p>INTLAB was designed and written by S.M. Rump, head of the Institute for Reliable Computing, Hamburg University of Technology. Suggestions are always welcome to rump (at) tuhh.de</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% DEMOGRADIENT  Short demonstration of gradients
%

%% Some sample applications of the gradient toolbox
% The gradient toolbox implements automatic differentiation in forward mode. 
%

%% Initialization of gradients
% In order to use automatic differentiation, the independent variables need
% to be identified and values have to be assigned. This is performed by
% the function "gradientinit". For example                            

format compact short _
u = gradientinit([ -3.1 ; 4e-3 ])

%%
% The total size of the input is the number of independent variables,   
% in the example 2, hence u represents a column vector of length 2 and
% defines two independent variables u(1) and u(2) with gradients [1 0]
% and [0 1], respectively.

%% Operations between gradients
% If at least one operand is of type gradient, operations are executed as 
% gradient operations.
% For example,                                                          

x = gradientinit(3.5);  
y = exp(3*x-sqrt(x))

%%
% For f(x):=exp(3*x-sqrt(x)), the result y contains in y.x the function value f(3.5)
% and in y.dx the derivative f'(3.5):
% 

y.x, y.dx

%% Complex arguments
% When evaluating the expression for another argument, use the same
% statement as before with new values.                                                 

x = gradientinit(-3.5+.2i);  
y = exp(3*x-sqrt(x))

%% Access to the gradient
% The principle works for functions in several unknowns the same way. Define, for
% example, the following function from R^3->R^3 :

f = @(x)( [ -2*x(1)*x(2)+4*x(3)^2 ; sin(x(2))/sqrt(pi-x(1)) ; atan(x(2)-x(3)) ] )
f([1.5;-1;0.7])

%%
% then the function value and gradient at [1.5;-1;0.7] is computed by

y = f(gradientinit([1.5;-1;0.7]))

%%
% where y.x contains the function value and y.dx the gradient, which is
% in this case the Jacobian. The gradient with respect the third unknown 
% x(3), for example, can be accessed by

y.dx(3,:)

%%
% However, it is recommended to use

y(3).dx

%%
% that is not to access the components of the gradient (Jacobian) but the
% gradient of the component. The advantage is visible when redefining the input function
% as a row vector:

f = @(x)( [ -2*x(1)*x(2)+4*x(3)^2  sin(x(2))/sqrt(pi-x(1))  atan(x(2)-x(3)) ] )
f([1.5;-1;0.7])

%%
% Then the "Jacobian" is a three-dimensional array
% because the gradient is always stored in the "next" dimension: 

y = f(gradientinit([1.5;-1;0.7]))

%%
% It is problematic to access the components of y.dx, while accessing the 
% gradient of the component works as expected:

y(3).dx

%% The inverse Gamma function
% We may want to calculate the inverse Gamma function using INTLAB's 
% verified Gamma function. For example, compute u such that gamma(u) = 100. 
% Consider the following simple Newton procedure with starting value u=5.

format long
u = gradientinit(5);
uold = u;
k = 0;
while abs(u.x-uold.x) > 1e-12*abs(u.x) | k < 1
  uold = u;
  k = k+1;
  y = gamma(u) - 100;
  u = u - y.x/y.dx;
end
k
u.x
gamma(u.x)


%% The inverse Gamma function with complex arguments
% Neither Matlab nor INTLAB provide the Gamma function for complex
% arguments. However, we may use an approximation by Stirling's formula.
% For u -> inf,                    
%
%                         1      1       139        571                  
%   Gamma(u) ~ C * ( 1 + REPLACE_WITH_DASH_DASH- + REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH- - REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH- - REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH- + ... )       
%                        12u       2         3           4               
%                              288u    51840u    2488320u    
%
% with
%
%        -u  u-0.5   
%   C = e   u      sqrt(2*pi) .                                           
%                                                                         
% The following function evaluates Stirling's formula. It is also         
% suited for vector input.                                                
%                                                                                                                                             
%   function y = g(u)                                                   
%       C = exp(-u) .* ( u.^(u-0.5) ) * sqrt(2.0*pi) ;                          
%       v = (((( -571.0/2488320.0 ./ u - 139.0/51840.0 ) ./ u ...              
%            + 1.0/288.0) ./ u ) + 1.0/12.0 ) ./ u + 1.0;                  
%       y = C .* v;                                                             
%                                                                        
% A corresponding inline function is

format long e
g = @(u) ( ( exp(-u) .* ( u.^(u-0.5) ) * sqrt(2.0*pi) ) .* ...
           ( (((( -571.0/2488320.0 ./ u - 139.0/51840.0 ) ./ u ...           
             + 1.0/288.0) ./ u ) + 1.0/12.0 ) ./ u + 1.0 ) )
u = [ 3.5 61 5 ]
g(u)
gamma(intval(u))

%%
% Note however that the approximation by Stirling's formula is of limited
% accuracy. The last line, a verified inclusion by INTLAB's Gamma function,
% indicates about 6 to 11 correct figures, depending on the magnitude of
% the argument.
%
% Using Stirling's formula we may search u with g(u) = 100 + 100i. 
% We use the same starting value u=5.
%                                                            

 u = gradientinit(5);
 uold = u;
 k = 0;
 while abs(u.x-uold.x) > 1e-12*abs(u.x) | k < 1
  uold = u;
  k = k+1;
  y = g(u) - 100 - 100i;
  u = u - y.x/y.dx;
 end
 k
 u.x
 g(u.x)

%%
% Due to approximation error in Stirling's formula, about six figures are correct.

%% Automatic differentiation with several unknowns
% Automatic differentiation with several unknowns works the same way.  
% Consider the following example by Broyden:
%                                                                             
%                               .5*sin(x1*x2) - x2/(4*pi) - x1/2  =  0         
% (1-1/(4*pi))*(exp(2*x1)-exp(1)) + exp(1)*x2/pi - 2*exp(1)*x1 )  =  0         
%                                                                              
% with initial approximation [ .6 ; 3 ] and one solution [ .5 ; pi ].           
% The following inline function evaluates Broyden's function.

f = @(x) ( [ .5*sin(x(1)*x(2)) - x(2)/(4*pi) - x(1)/2 ; ...
             (1-1/(4*pi))*(exp(2*x(1))-exp(1)) + exp(1)*x(2)/pi - 2*exp(1)*x(1) ] )

%% Solution of a nonlinear system
% The nonlinear system defined by Broyden's function is solved by Newton's procedure as follows:                                                                           

 x = gradientinit([ .6 ; 3 ]);
 for i=1:5
  y = f(x);
  x = x - y.dx\y.x;
 end
 x

%%                                                             
% For simplicity, we omitted the stopping criterion (see above).   
% Here, y.dx is the Jacobian, y.x the function value at x.x, and -y.dx\y.x  
% is the correction obtained by the (approximate) solution of a linear system.                
%                                                                           

%% Verified solution of the nonlinear system
% For verified solution of the nonlinear system, we need a correct definition  
% of the function. The main point is to make sure that a function evaluation with
% interval argument computes an inclusion of the function value. So first the
% transcendental number pi has to be replaced by an interval containing pi:

cPi = intval('pi')

%%
% Second, Broyden's function contains exp(1), which would be computed in pure
% floating-point without extra care. This can be cured using exp(intval(1)).
%
% However, a new problem arises. 
% When replacing "pi" in the function by "cPi" and 1 by intval(1), the function is       
% _always_ evaluated in interval arithmetic; a pure floating point iteration     
% is no longer possible. 
%
% To solve this problem, we have to know the type of     
% the incoming unknown "x". If "x" is double, replace "cPi" and intval(1) by its midpoint,   
% if "x" is an interval, use "cPi" and intval(1) as is. This is done as follows.             
%                                                                               
%  function  y = f(x)                                                           
%    y = x;
%    c1 = typeadj( 1 , typeof(x) );
%    cpi = typeadj( midrad(3.14159265358979323,1e-16) , typeof(x) );
%    y(1) = .5*sin(x(1)*x(2)) - x(2)/(4*cpi) - x(1)/2;
%    y(2) = (1-1/(4*cpi))*(exp(2*x(1))-exp(c1)) + exp(c1)*x(2)/cpi - 2*exp(c1)*x(1);
%                                                                               
% This code is implemented in the function Broyden.m .

%% Real and interval function evaluation
% Consider the following two function evaluations. First, f(x) is evaluated
% for real argument:

x = [ .6 ; 3 ];  
Broyden(x)

%% 
% Second, f(x) is evaluated with interval argument:

format _
x = [intval('.6') ; 3 ] 
y = Broyden(x)

%%
% The mathematical statement is the following. First, x is an interval vector
% such that x(1) is an inclusion of 0.6 and x(2)=3. Second, cPi is an interval
% containg the transcendental number pi. Third, y is an interval vector 
% containing the exact value of Broyden's function evaluated at [ .6 ; 3 ].

%% Gradient function evaluation using ordinary intervals
% Finally, we may define the interval x to be of type gradient:

x = gradientinit([intval('.6') ; 3 ])
Y = Broyden(x)

%%
% The mathematical statement is that Y is an interval vector such that Y.x
% contains the exact value of Broyden's function evaluated at [ .6 ; 3 ], and
% Y.dx is an interval matrix containing the Jacobian of Broyden's function
% evaluated at [ .6 ; 3 ].
                                                                          
%% Gradient function evaluation using affine intervals
% We may use affine arithmetic in gradient evaluations as well, for details
% see the affari demo:

x = gradientinit([affari(.6) ; 3 ])
Y = Broyden(x)

%% Verified solution of the nonlinear system with Broyden's function
% The nonlinear system with Broyden's function and the given starting value
% [ .6 ; 3 ] can be solved with verification by         

Y = verifynlss(@Broyden,[ .6 ; 3 ])
                               
%%
% The first parameter gives the name of the function such that Broyden(x) 
% evaluates the function at "x". The result vector Y is verified to contain
% a real vector xhat such that f(xhat)=0. This solution X of the nonlinear system
% is proved to be unique within Y. This statement is mathematically true,
% it is taken care of all procedural, approximation and rounding errors. 
%
% It follows that an inclusion is not possible if roots are very close
% together or multiple:
% Since uniqueness of the root is proved, an inclusion is only possible if roots
% can be separated. An escape of that is described in DEMOSLOPE.

%% All roots of Broyden's function
% The root [ 0.5 ; pi ] is mentioned in the literature, however, there are
% many more roots. For example, there are seven roots in the box [-10,10]^2

format short
L = verifynlssall(@Broyden,infsup(-10,10)*ones(2,1))

%%
% For more details, please visit the demo on global routines by demo toolbox intlab .

%% Verified solution of a nonlinear system with sparse gradients
% Up to now we considered only toy examples to explain how the nonlinear
% system solver works. For a larger example consider the following example
% proposed by Abbot and Brent, which is implemented in the function test.
%

%%
%  function y = test(x);
%  % Abbot/Brent     3 y" y + y'^2 = 0;    y(0)=0; y(1)=20;
%  % approximation   10*ones(n,1)
%  % solution        20*x^.75
%    y = x;
%    n = length(x); v=2:n-1;
%    y(1) = 3*x(1)*(x(2)-2*x(1)) + x(2)*x(2)/4;
%    y(v) = 3*x(v).*(x(v+1)-2*x(v)+x(v-1)) + (x(v+1)-x(v-1)).^2/4;
%    y(n) = 3*x(n).*(20-2*x(n)+x(n-1)) + (20-x(n-1)).^2/4;
%
% An inclusion of the solution for 1000 unknowns is computed by
%

format short
sparsegradient(50)
n = 1000; 
tic
x = verifynlss(@test,10*ones(n,1)); 
toc
max(relerr(x))

%% Verified solution of a nonlinear system with full gradients
% Here we specified that gradients with 50 unknowns and more are stored
% in sparse mode. This is the default when calling "sparsegradient". 
%
% Forcing gradients to use full storage results in a significantly increase
% of computing time. 

sparsegradient(inf)
n = 1000; 
tic
x = verifynlss(@test,10*ones(n,1)); 
toc
max(relerr(x))
 
%% Verified solution of a nonlinear system with 10,000 unknowns
% Note that the inclusion is of high accuracy. The results for a larger
% nonlinear system with 10,000 unknowns is as follows.
 
sparsegradient(0)
n = 10000; 
tic
x = verifynlss(@test,10*ones(n,1)); 
toc
max(relerr(x))


%% Non-differentiable functions
% The given function need not be differentiable everywhere. Consider, for example,

f = inline('abs(x)')
f(gradientinit(infsup(-.1,2)))

%% Verified solution of non-differentiable functions 
% The inclusion of a root is searched for near the given approximation. Consider

f = vectorize(inline('x*sinh(x)-3*exp(abs(x)-.5)+x*cos(x+1)+2*cosh(x)'))
close
x=linspace(-1,2.3);
plot(x,f(x),x,0*x)

%%
% It seems there are three roots. Indeed,

format long
verifynlss(f,-.5)
verifynlss(f,.5)
verifynlss(f,2)

%%
% there are three roots, and the inlcusions are of high accuracy. One can
% also calculate an inclusion of multiple roots. Since the problem is ill-posed,
% it has to be regularized. Consider

X = verifynlss2(@(x)(sin(x)-1),1.5)

%%
% It is proved that there exists some parameter e in X(2) such that the function 
% g(x):=f(x)-e has a truely double root in X(1). Note the accuracy of the inclusions.
% It looks like the inclusion of e is a true zero. However, this is due to the "_"-format:
% add +/-1 to the last visible digit produces a valid inclusion:

format long e infsup
X

%%
% The function "verifynlss2" is applicable to multivariate functions as well.
% For more details, see "help verifynlss" or "help verifynlss2" or
%
%  S.M. Rump: Verification methods: Rigorous results using floating-point arithmetic.
%    Acta Numerica, 19:287-449, 2010. 
%
% to be downloaded from "www.ti3.tuhh.de/rump" and the literature cited over there.

%% Enjoy INTLAB
% INTLAB was designed and written by S.M. Rump, head of the Institute for Reliable Computing,
% Hamburg University of Technology. Suggestions are always welcome to rump (at) tuhh.de

##### SOURCE END #####
--></body></html>