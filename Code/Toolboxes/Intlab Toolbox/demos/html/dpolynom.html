
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>DEMOPOLYNOM  Short demo of the polynom toolbox</title><meta name="generator" content="MATLAB 9.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2017-07-22"><meta name="DC.source" content="dpolynom.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>DEMOPOLYNOM  Short demo of the polynom toolbox</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">Definition of a univariate polynomial</a></li><li><a href="#4">Access to coefficients, exponents and variables I</a></li><li><a href="#6">Definition of a multivariate polynomial</a></li><li><a href="#7">Random polynomials</a></li><li><a href="#9">Access to coefficients, exponents and variables II</a></li><li><a href="#10">Display of polynomials</a></li><li><a href="#12">Operations between polynomials</a></li><li><a href="#14">Interval polynomials</a></li><li><a href="#16">Plot of polynomials</a></li><li><a href="#18">Access of coefficients I</a></li><li><a href="#19">Access of coefficients II</a></li><li><a href="#20">Subpolynomials</a></li><li><a href="#21">Polynomial evaluation</a></li><li><a href="#22">Interval polynomial evaluation</a></li><li><a href="#24">Evaluation of subpolynomials</a></li><li><a href="#25">Derivatives of polynomials</a></li><li><a href="#27">Bernstein polynomials</a></li><li><a href="#30">Polynomial evaluation and Bernstein polynomials</a></li><li><a href="#33">Inclusion of roots of polynomials</a></li><li><a href="#36">Inclusion of clustered or multiple roots of polynomials</a></li><li><a href="#39">Quality of the computed bounds</a></li><li><a href="#40">Quality of the computed bounds for coefficients with tolerances</a></li><li><a href="#41">Sylvester matrix</a></li><li><a href="#42">Predefined polynomials</a></li><li><a href="#43">Enjoy INTLAB</a></li></ul></div><pre class="codeinput">format <span class="string">compact</span> <span class="string">short</span>
setround(0)                           <span class="comment">% set rounding to nearest</span>
</pre><h2 id="2">Definition of a univariate polynomial</h2><p>The simplest way to generate a univariate polynomial is (like in Matlab) by</p><pre class="codeinput">p = polynom([1 -3 0 4])
</pre><pre class="codeoutput">polynom p[x] = 
    1.0000  x^3  
   -3.0000  x^2  
    4.0000       
</pre><p>Note we use the German word Polynom, saving three letters :)</p><p>It generates a polynomial (of the INTLAB data type "polynom") with coefficients 1, -3, 0 and 4. Note that the coefficient corresponding to the highest exponent is specified first, and that the default dependent variable is "x". Another variable can be specified explicitly, e.g. by</p><pre class="codeinput">q = polynom([1 0 -2],<span class="string">'y'</span>)
</pre><pre class="codeoutput">polynom q[y] = 
    1.0000  y^2  
   -2.0000       
</pre><h2 id="4">Access to coefficients, exponents and variables I</h2><p>There is direct access to the vector of polynomial coefficients (starting with the largest exponent), the vector of exponents and the independent variable in use:</p><pre class="codeinput">coeff = q.c
expon = q.e
vars = q.v
</pre><pre class="codeoutput">coeff =
     1     0    -2
expon =
     2
vars =
    'y'
</pre><p>The polynomial may also be specified by the individual coefficients and exponents. The polynomial p, for example, is also generated as follows:</p><pre class="codeinput">polynom([1 -3 4],[3 2 0])
</pre><pre class="codeoutput">polynom ans[x] = 
    1.0000  x^3  
   -3.0000  x^2  
    4.0000       
</pre><h2 id="6">Definition of a multivariate polynomial</h2><p>A multivariate polynomial is generated by specifying coefficients and corresponding exponents. An example is</p><pre class="codeinput">P = polynom([-3 4 9],[2 3;4 0;2 2],{<span class="string">'a'</span> <span class="string">'b'</span>})
</pre><pre class="codeoutput">polynom P[a,b] = 
    4.0000  a^4       
   -3.0000  a^2  b^3  
    9.0000  a^2  b^2  
</pre><h2 id="7">Random polynomials</h2><p>A multivariate polynomial may generated randomly by</p><pre class="codeinput">Q = randpoly(4,2)
</pre><pre class="codeoutput">polynom Q[x1,x2] = 
   -0.1997  x1^2        
    0.2469  x1    x2^2  
    0.8899  x1    x2    
   -0.8120        x2    
   -0.4930              
</pre><p>where the first parameter specifies the degree and the second the number of variables. Note that the variables are "x1", "x2", ... by default. This may be changed by specifying other variable names explicitly:</p><pre class="codeinput">QQ = randpoly(4,2,{<span class="string">'var1'</span> <span class="string">'var2'</span>})
</pre><pre class="codeoutput">polynom QQ[var1,var2] = 
    0.4912  var1^4  var2^2  
   -0.8745  var1^2  var2^3  
   -0.1344  var1    var2^2  
   -0.4434  var1    var2    
    0.0067          var2^4  
   -0.7536          var2    
</pre><h2 id="9">Access to coefficients, exponents and variables II</h2><p>As before there is also direct access to the polynomial coefficients, the exponents and the independent variables for multivariate polynomials:</p><pre class="codeinput">coeff = QQ.c
expon = QQ.e
vars = QQ.v
</pre><pre class="codeoutput">coeff =
    0.4912
   -0.8745
   -0.1344
   -0.4434
    0.0067
   -0.7536
expon =
     4     2
     2     3
     1     2
     1     1
     0     4
     0     1
vars =
  1&times;2 cell array
    {'var1'}    {'var2'}
</pre><h2 id="10">Display of polynomials</h2><p>Univariate polynomials may be displayed in dense or sparse mode, for example</p><pre class="codeinput">format <span class="string">upolyvector</span>
p
</pre><pre class="codeoutput">polynom p[x]  = 
     1    -3     0     4
</pre><pre class="codeinput">format <span class="string">upolysparse</span>
p
</pre><pre class="codeoutput">polynom p[x] = 
    1.0000  x^3  
   -3.0000  x^2  
    4.0000       
</pre><h2 id="12">Operations between polynomials</h2><p>Operations between univariate polynomials are as usual</p><pre class="codeinput">p, 3*p+1
</pre><pre class="codeoutput">polynom p[x] = 
    1.0000  x^3  
   -3.0000  x^2  
    4.0000       
polynom ans[x] = 
    3.0000  x^3  
   -9.0000  x^2  
   13.0000       
</pre><p>and may produce multivariate polynomials if not depending on the same variable:</p><pre class="codeinput">q, p+q
</pre><pre class="codeoutput">polynom q[y] = 
    1.0000  y^2  
   -2.0000       
polynom ans[x,y] = 
    1.0000  x^3       
   -3.0000  x^2       
    1.0000       y^2  
    2.0000            
</pre><h2 id="14">Interval polynomials</h2><p>Interval polynomials are specified in the same way as before. Consider, for example (taken from Hansen/Walster: Sharp Bounds for Interval Polynomial Roots, Reliable Computing 8(2) 2002)</p><pre class="codeinput">format <span class="string">infsup</span>
r = polynom([infsup(1,2) infsup(-4,2) infsup(-3,1)])
</pre><pre class="codeoutput">intval polynom r[x] = 
[    1.0000,    2.0000]   x^2  
[   -4.0000,    2.0000]   x    
[   -3.0000,    1.0000]        
</pre><p>The polynomial may be displayed using other interval formats, for example</p><pre class="codeinput">format <span class="string">midrad</span>
r
</pre><pre class="codeoutput">intval polynom r[x] = 
&lt;    1.5000,   0.5000&gt;   x^2  
&lt;   -1.0000,   3.0000&gt;   x    
&lt;   -1.0000,   2.0000&gt;        
</pre><h2 id="16">Plot of polynomials</h2><p>The following plots the lower and upper bound polynomial within root bounds:</p><pre class="codeinput">plotpoly(r)
</pre><img vspace="5" hspace="5" src="dpolynom_01.png" alt=""> <p>or within specified bounds:</p><pre class="codeinput">plotpoly(r,-2,2)
</pre><img vspace="5" hspace="5" src="dpolynom_02.png" alt=""> <h2 id="18">Access of coefficients I</h2><p>In contrast to Matlab, coefficients of INTLAB polynomials are set and accessed as in mathematics:</p><pre class="codeinput">q = p+1
coeff3 = q(3)
q(0) = -2
q(0:2) = 4.7
</pre><pre class="codeoutput">polynom q[x] = 
    1.0000  x^3  
   -3.0000  x^2  
    5.0000       
coeff3 =
     1
polynom q[x] = 
    1.0000  x^3  
   -3.0000  x^2  
   -2.0000       
polynom q[x] = 
    1.0000  x^3  
    4.7000  x^2  
    4.7000  x    
    4.7000       
</pre><h2 id="19">Access of coefficients II</h2><p>Access of coefficients for multivariate polynomials works the same way by specifying the position for the individual variables:</p><pre class="codeinput">P = polynom([-3 4 9],[2 3;4 0;2 2],{<span class="string">'a'</span> <span class="string">'b'</span>})
coeff23 = P(2,3)
P(1,4) = -9
</pre><pre class="codeoutput">polynom P[a,b] = 
    4.0000  a^4       
   -3.0000  a^2  b^3  
    9.0000  a^2  b^2  
coeff23 =
    -3
polynom P[a,b] = 
    4.0000  a^4       
   -3.0000  a^2  b^3  
    9.0000  a^2  b^2  
   -9.0000  a    b^4  
</pre><h2 id="20">Subpolynomials</h2><p>Subpolynomials may be accessed by specifying certain unknowns as []. This corresponds to a distributive representation of the polynomial:</p><pre class="codeinput">P
Q = P(2,[])
</pre><pre class="codeoutput">polynom P[a,b] = 
    4.0000  a^4       
   -3.0000  a^2  b^3  
    9.0000  a^2  b^2  
   -9.0000  a    b^4  
polynom Q[b] = 
   -3.0000  b^3  
    9.0000  b^2  
</pre><h2 id="21">Polynomial evaluation</h2><p>There are two (equivalent) possibilities of polynomial evaluation, by polyval or by {}:</p><pre class="codeinput">p = polynom([1 -3 0 4])
polyval(p,2)
p{2}
</pre><pre class="codeoutput">polynom p[x] = 
    1.0000  x^3  
   -3.0000  x^2  
    4.0000       
ans =
     0
ans =
     0
</pre><h2 id="22">Interval polynomial evaluation</h2><p>Of course, verified bounds are obtained in the well known ways:</p><pre class="codeinput">polyval(intval(p),2)
p{intval(2)}
</pre><pre class="codeoutput">intval ans = 
&lt;    0.0000,   0.0000&gt; 
intval ans = 
&lt;    0.0000,   0.0000&gt; 
</pre><p>Polynomial evaluation for multivariate polynomials works the same way:</p><pre class="codeinput">P = polynom([-3 4 9],[2 3;4 0;2 2],{<span class="string">'a'</span> <span class="string">'b'</span>})
polyval(P,2,3)
P{2,intval(3)}
</pre><pre class="codeoutput">polynom P[a,b] = 
    4.0000  a^4       
   -3.0000  a^2  b^3  
    9.0000  a^2  b^2  
ans =
    64
intval ans = 
&lt;   64.0000,   0.0000&gt; 
</pre><h2 id="24">Evaluation of subpolynomials</h2><p>In addition, evaluation of sub- (or coefficient-) polynomials is possible by specifying certain unknowns as []. Unknowns specified by [] are still treated as independent variables. In this case the argument list must be one cell array:</p><pre class="codeinput">polyval(P,{2,[]})
P{{[],intval(3)}}
</pre><pre class="codeoutput">polynom ans[b] = 
  -12.0000  b^3  
   36.0000  b^2  
   64.0000       
intval polynom ans[a] = 
&lt;    4.0000,   0.0000&gt;   a^4  
</pre><h2 id="25">Derivatives of polynomials</h2><p>First and higher polynomial derivatives are calculated by</p><pre class="codeinput">p
p'
pderiv(p,2)
</pre><pre class="codeoutput">polynom p[x] = 
    1.0000  x^3  
   -3.0000  x^2  
    4.0000       
polynom ans[x] = 
    3.0000  x^2  
   -6.0000  x    
polynom ans[x] = 
    6.0000  x    
   -6.0000       
</pre><p>or, for multivariate polynomials, by specifiying the variable:</p><pre class="codeinput">P = polynom([-3 4 9],[2 3;4 0;2 2],{<span class="string">'a'</span> <span class="string">'b'</span>})
pderiv(P,<span class="string">'a'</span>)
pderiv(P,<span class="string">'b'</span>,2)
</pre><pre class="codeoutput">polynom P[a,b] = 
    4.0000  a^4       
   -3.0000  a^2  b^3  
    9.0000  a^2  b^2  
polynom ans[a,b] = 
   16.0000  a^3       
   -6.0000  a    b^3  
   18.0000  a    b^2  
polynom ans[a,b] = 
  -18.0000  a^2  b    
   18.0000  a^2       
</pre><h2 id="27">Bernstein polynomials</h2><p>A simple application is the computation of Bernstein coefficients. Consider</p><pre class="codeinput">P = polynom([2 -3 0 3 1 -2])
</pre><pre class="codeoutput">polynom P[x] = 
    2.0000  x^5  
   -3.0000  x^4  
    3.0000  x^2  
    1.0000  x    
   -2.0000       
</pre><p>Suppose, we wish to expand the polynomial in the interval [-1,1]. Since Bernstein coefficients B_i are calculated with respect to [0,1], we first transform the polynomial:</p><pre class="codeinput">Q = ptrans(P,-1,1,0,1);
B = bernsteincoeff(Q)
</pre><pre class="codeoutput">polynom B[x] = 
    1.0000  x^5  
   -1.0000  x^4  
   -1.0000  x^3  
   -5.4000  x^2  
    1.8000  x    
   -5.0000       
</pre><p>For convenient use, the Bernstein coefficients are stored in a polynomial such that B(i) is the i-th Bernstein coefficient for i=0:n.</p><h2 id="30">Polynomial evaluation and Bernstein polynomials</h2><p>The convex hull of Bernstein points B contains the convex hull of the polynomial:</p><pre class="codeinput">plotpoly(P,-1,1);
hold <span class="string">on</span>
plotbernstein(B,-1,1)
hold <span class="string">off</span>
</pre><img vspace="5" hspace="5" src="dpolynom_03.png" alt=""> <p>This picture is not untypical. The Bernstein points overestimate the true range, but sometimes not too much. To obtain a true inclusion of the range, we perform the computation with verified bounds:</p><pre class="codeinput">format <span class="string">infsup</span>
Q = ptrans(intval(P),-1,1,0,1);
B = bernsteincoeff(Q),
X = P{infsup(-1,1)},
Y = infsup(min(B.c.inf),max(B.c.sup))
</pre><pre class="codeoutput">intval polynom B[x] = 
[    1.0000,    1.0000]   x^5  
[   -1.0001,   -0.9999]   x^4  
[   -1.0000,   -0.9999]   x^3  
[   -5.4001,   -5.3999]   x^2  
[    1.7999,    1.8001]   x    
[   -5.0000,   -5.0000]        
intval X = 
[  -11.0000,    7.0000] 
intval Y = 
[   -5.4001,    1.8001] 
</pre><p>From the picture we read the true range [-5,1] which is slightly overestimated by Y computed by the Bernstein approach. The same principle can be applied to multivariate polynomials.</p><h2 id="33">Inclusion of roots of polynomials</h2><p>Roots of a univariate polynomial can approximated and included. Consider a polynomial with roots 1,2,...,7:</p><pre class="codeinput">format <span class="string">long</span>
p = polynom(poly(1:7))
roots(p)                  <span class="comment">% approximations of the roots</span>
</pre><pre class="codeoutput">polynom p[x] = 
  1.0e+004 *
   0.00010000000000  x^7  
  -0.00280000000000  x^6  
   0.03220000000000  x^5  
  -0.19600000000000  x^4  
   0.67690000000000  x^3  
  -1.31320000000000  x^2  
   1.30680000000000  x    
  -0.50400000000000       
ans =
   6.999999999999008
   6.000000000002801
   4.999999999997638
   4.000000000000223
   3.000000000000553
   1.999999999999781
   1.000000000000020
</pre><p>Based on some approximation (in this case near 4.1), verified bounds for a root are obtained by</p><pre class="codeinput">verifypoly(p,4.1)
</pre><pre class="codeoutput">intval ans = 
[   3.99999999999739,   4.00000000000329] 
</pre><p>Note that the accuracy of the bounds is of the order of the (usually unknown) sensitivity of the root.</p><h2 id="36">Inclusion of clustered or multiple roots of polynomials</h2><p>The routine "verifypoly" calculates verified bounds for multiple roots as well. Consider the polynomial with three 4-fold roots at x=1, x=2 and x=3:</p><pre class="codeinput">format <span class="string">short</span> <span class="string">midrad</span>
p = polynom(poly([1 1 1 1 2 2 2 2 3 3 3 3])); roots(p)
</pre><pre class="codeoutput">ans =
   3.0063 + 0.0000i
   2.9936 + 0.0000i
   3.0000 + 0.0064i
   3.0000 - 0.0064i
   2.0074 + 0.0000i
   1.9927 + 0.0000i
   2.0000 + 0.0074i
   2.0000 - 0.0074i
   1.0016 + 0.0000i
   0.9984 + 0.0000i
   1.0000 + 0.0016i
   1.0000 - 0.0016i
</pre><p>Based on some approximation (in this case 2.001), verified bounds for a multiple root are obtained by</p><pre class="codeinput">verifypoly(p,2.001)
</pre><pre class="codeoutput">intval ans = 
&lt;    2.0000,   0.0051&gt; 
</pre><p>Note that the accuracy of the bounds is of the order of the sensitivity of the root, i.e. of the order eps^(1/4) = 1.2e-4. The multiplicity of the root is determined as well (for details, see "verifypoly").</p><pre class="codeinput">[X,k] = verifypoly(p,2.999)
</pre><pre class="codeoutput">intval X = 
&lt;    3.0000,   0.0053&gt; 
k =
     4
</pre><h2 id="39">Quality of the computed bounds</h2><p>One may argue that the previous inclusion is rather broad. But look at the graph of the polynomial near x=3:</p><pre class="codeinput">p = polynom(poly([1 1 1 1 2 2 2 2 3 3 3 3]));
plotpoly(p,2.99,3.01)
title(<span class="string">'Floating point evaluation of p near x=3'</span>)
</pre><img vspace="5" hspace="5" src="dpolynom_04.png" alt=""> <h2 id="40">Quality of the computed bounds for coefficients with tolerances</h2><p>Due to rounding and cancellation errors the accuracy of the inclusion is about optimal. Things are even more drastic when the polynomial coefficients are afflicted with tolerances. Put smallest possible intervals around the coefficients of p and look at the graph. Between about 2.993 and 3.007 the lower and upper bound enclose zero.</p><pre class="codeinput">P = polynom(midrad(p.c,1e-16));
plotpoly(P,2.99,3.01)
title(<span class="string">'Interval polynomial P near x=3'</span>)
</pre><img vspace="5" hspace="5" src="dpolynom_05.png" alt=""> <h2 id="41">Sylvester matrix</h2><p>The Sylvester matrix of two polynomials p,q is singular if and only if p and q have a root in common. Therefore, the Sylvester matrix of p and p' may determine whether p has multiple roots. Note, however, that this test is not numerically stable.</p><pre class="codeinput">format <span class="string">short</span>
p = polynom(poly([2-3i 2-3i randn(1,3)]))       <span class="comment">% polynomial with double root 2-3i</span>
roots(p)
S = sylvester(p);         <span class="comment">% Sylvester matrix of p and p'</span>
format <span class="string">short</span> <span class="string">e</span>
svd(S)
</pre><pre class="codeoutput">polynom p[x] = 
   1.0000 +   0.0000i  x^5  
  -5.4696 +   6.0000i  x^4  
   1.3974 -  20.8177i  x^3  
   5.2709 +  20.7491i  x^2  
  -2.5896 -   6.2353i  x    
   0.0065 +   0.0156i       
ans =
   2.0000 - 3.0000i
   2.0000 - 3.0000i
   0.8846 - 0.0000i
   0.5825 + 0.0000i
   0.0025 - 0.0000i
ans =
   1.4433e+02
   1.0826e+02
   6.7054e+01
   3.4015e+01
   1.4027e+01
   1.4196e+00
   1.0336e+00
   5.9564e-02
   2.2366e-15
</pre><h2 id="42">Predefined polynomials</h2><p>There are a number of predefined polynomials such as Chebyshev, Gegenbauer, Hermite polynomials etc.</p><h2 id="43">Enjoy INTLAB</h2><p>INTLAB was designed and written by S.M. Rump, head of the Institute for Reliable Computing, Hamburg University of Technology. Suggestions are always welcome to rump (at) tuhh.de</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% DEMOPOLYNOM  Short demo of the polynom toolbox
%
%%

format compact short
setround(0)                           % set rounding to nearest    
    
%% Definition of a univariate polynomial
% The simplest way to generate a univariate polynomial is (like in Matlab) by
        
p = polynom([1 -3 0 4])
        
%%
% Note we use the German word Polynom, saving three letters :)
%
% It generates a polynomial (of the INTLAB data type "polynom") with 
% coefficients 1, -3, 0 and 4. Note that the coefficient 
% corresponding to the highest exponent is specified first, and that the default dependent
% variable is "x". Another variable can be specified explicitly, e.g. by 
       
q = polynom([1 0 -2],'y')

%% Access to coefficients, exponents and variables I
% There is direct access to the vector of polynomial coefficients (starting with 
% the largest exponent), the vector of exponents and the independent variable in use:

coeff = q.c
expon = q.e
vars = q.v

%%
% The polynomial may also be specified by the individual coefficients and exponents. The 
% polynomial p, for example, is also generated as follows:
       
polynom([1 -3 4],[3 2 0])

%% Definition of a multivariate polynomial
% A multivariate polynomial is generated by specifying coefficients and corresponding 
% exponents. An example is 

P = polynom([-3 4 9],[2 3;4 0;2 2],{'a' 'b'})
        
%% Random polynomials
% A multivariate polynomial may generated randomly by
 
Q = randpoly(4,2)
        
%%
% where the first parameter specifies the degree and the second the number of variables.
% Note that the variables are "x1", "x2", ... by default. This may be changed by specifying
% other variable names explicitly:
        
QQ = randpoly(4,2,{'var1' 'var2'}) 

%% Access to coefficients, exponents and variables II
% As before there is also direct access to the polynomial coefficients, the exponents 
% and the independent variables for multivariate polynomials:

coeff = QQ.c
expon = QQ.e
vars = QQ.v

     
%% Display of polynomials
% Univariate polynomials may be displayed in dense or sparse mode, for example

format upolyvector
p

%%

format upolysparse
p
       
%% Operations between polynomials
% Operations between univariate polynomials are as usual
       
p, 3*p+1
       
%%
% and may produce multivariate polynomials if not depending on the same variable:
     
q, p+q
      
%% Interval polynomials 
% Interval polynomials are specified in the same way as before. Consider, for example (taken from 
% Hansen/Walster: Sharp Bounds for Interval Polynomial Roots, Reliable Computing 8(2) 2002)
      
format infsup
r = polynom([infsup(1,2) infsup(-4,2) infsup(-3,1)])
      
%%
% The polynomial may be displayed using other interval formats, for example
        
format midrad
r
       
%% Plot of polynomials
% The following plots the lower and upper bound polynomial within root bounds:
       
plotpoly(r)
      
%%
% or within specified bounds:
       
plotpoly(r,-2,2)
      
%% Access of coefficients I
% In contrast to Matlab, coefficients of INTLAB polynomials are set and accessed as in mathematics: 
       
q = p+1
coeff3 = q(3)
q(0) = -2
q(0:2) = 4.7 
     
%% Access of coefficients II
% Access of coefficients for multivariate polynomials works the same way by specifying
% the position for the individual variables:
       
P = polynom([-3 4 9],[2 3;4 0;2 2],{'a' 'b'})
coeff23 = P(2,3)
P(1,4) = -9

%% Subpolynomials
% Subpolynomials may be accessed by specifying certain unknowns as []. This corresponds
% to a distributive representation of the polynomial:

P
Q = P(2,[])  
        
%% Polynomial evaluation
% There are two (equivalent) possibilities of polynomial evaluation, by polyval or by {}:

p = polynom([1 -3 0 4])
polyval(p,2)
p{2}

%% Interval polynomial evaluation
% Of course, verified bounds are obtained in the well known ways:
        
polyval(intval(p),2)
p{intval(2)}
        
%%
% Polynomial evaluation for multivariate polynomials works the same way:
      
P = polynom([-3 4 9],[2 3;4 0;2 2],{'a' 'b'})
polyval(P,2,3)
P{2,intval(3)}
     
%% Evaluation of subpolynomials
% In addition, evaluation of sub- (or coefficient-) polynomials is possible by specifying
% certain unknowns as []. Unknowns specified by [] are still treated as independent variables.
% In this case the argument list must be one cell array:
     
polyval(P,{2,[]})
P{{[],intval(3)}}
        
%% Derivatives of polynomials
% First and higher polynomial derivatives are calculated by
        
p
p'
pderiv(p,2)
        
%%
% or, for multivariate polynomials, by specifiying the variable:
         
P = polynom([-3 4 9],[2 3;4 0;2 2],{'a' 'b'})
pderiv(P,'a')
pderiv(P,'b',2)

%% Bernstein polynomials
% A simple application is the computation of Bernstein coefficients. Consider 
     
P = polynom([2 -3 0 3 1 -2])
  
%%
% Suppose, we wish to expand the polynomial in the interval [-1,1]. Since Bernstein coefficients B_i
% are calculated with respect to [0,1], we first transform the polynomial:
       
Q = ptrans(P,-1,1,0,1); 
B = bernsteincoeff(Q)
 
%%
% For convenient use, the Bernstein coefficients are stored in a polynomial such that B(i) 
% is the i-th Bernstein coefficient for i=0:n. 

%% Polynomial evaluation and Bernstein polynomials
% The convex hull of 
% Bernstein points B contains the convex hull of the polynomial:
        
plotpoly(P,-1,1); 
hold on
plotbernstein(B,-1,1)
hold off
  
        
%% 
% This picture is not untypical. The Bernstein points overestimate the true range, 
% but sometimes not too much. To obtain a true inclusion of the range, we perform 
% the computation with verified bounds:    

format infsup
Q = ptrans(intval(P),-1,1,0,1); 
B = bernsteincoeff(Q), 
X = P{infsup(-1,1)}, 
Y = infsup(min(B.c.inf),max(B.c.sup))
       
%%
% From the picture we read the true range [-5,1] which is slightly overestimated by Y computed by
% the Bernstein approach. The same principle can be applied to multivariate polynomials.
    

%% Inclusion of roots of polynomials
% Roots of a univariate polynomial can approximated and included. 
% Consider a polynomial with roots 1,2,...,7:
     
format long
p = polynom(poly(1:7))
roots(p)                  % approximations of the roots
       
%%
% Based on some approximation (in this case near 4.1), verified bounds for a root are obtained by
       
verifypoly(p,4.1)
       
%%
% Note that the accuracy of the bounds is of the order of the (usually unknown) 
% sensitivity of the root.
      
%% Inclusion of clustered or multiple roots of polynomials
% The routine "verifypoly" calculates verified bounds for multiple roots as well.
% Consider the polynomial with three 4-fold roots at x=1, x=2 and x=3:
             
format short midrad
p = polynom(poly([1 1 1 1 2 2 2 2 3 3 3 3])); roots(p)

%%
% Based on some approximation (in this case 2.001), verified bounds for a multiple root are obtained by
     
verifypoly(p,2.001)
  
%%
% Note that the accuracy of the bounds is of the order of the sensitivity of the root, i.e. of the order
% eps^(1/4) = 1.2e-4. The multiplicity of the root is determined as well (for details, see "verifypoly").
     
[X,k] = verifypoly(p,2.999)

%% Quality of the computed bounds 
% One may argue that the previous inclusion is rather broad. But look at the graph of the polynomial near x=3:
    
p = polynom(poly([1 1 1 1 2 2 2 2 3 3 3 3]));
plotpoly(p,2.99,3.01)
title('Floating point evaluation of p near x=3')
 
%% Quality of the computed bounds for coefficients with tolerances
% Due to rounding and cancellation errors the accuracy of the inclusion is about optimal. Things are
% even more drastic when the polynomial coefficients are afflicted with tolerances. Put smallest possible
% intervals around the coefficients of p and look at the graph.
% Between about 2.993 and 3.007 the lower and upper bound enclose zero.
       
P = polynom(midrad(p.c,1e-16));  
plotpoly(P,2.99,3.01)
title('Interval polynomial P near x=3')

%% Sylvester matrix
% The Sylvester matrix of two polynomials p,q is singular 
% if and only if p and q have a root in common. 
% Therefore, the Sylvester matrix of p and p' may determine whether p has multiple roots.
% Note, however, that this test is not numerically stable.

format short
p = polynom(poly([2-3i 2-3i randn(1,3)]))       % polynomial with double root 2-3i
roots(p)
S = sylvester(p);         % Sylvester matrix of p and p'
format short e
svd(S)

%% Predefined polynomials
% There are a number of predefined polynomials such as Chebyshev, Gegenbauer, Hermite polynomials etc. 

%% Enjoy INTLAB
% INTLAB was designed and written by S.M. Rump, head of the Institute for Reliable Computing,
% Hamburg University of Technology. Suggestions are always welcome to rump (at) tuhh.de

##### SOURCE END #####
--></body></html>